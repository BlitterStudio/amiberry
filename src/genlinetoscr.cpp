/*
* UAE - The portable Amiga Emulator
*
* Generate Denise/Lisa emulation pixel output code.
*
* (c) 2024 Toni Wilen
*/

#include "sysconfig.h"
#include "sysdeps.h"

#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>

static FILE *outfile;
static int outfile_indent = 0;
static int aga, outres, res, planes, modes, bplfmode, sprres, oddeven, ecsshres, genlock, ntsc, filtered, modetype;
static int isbuf2 = 0;
static int maxplanes = 8;
static char funcnames[500000], funcnamesf[500000];
static char *funcnamep, *funcnamepf;

typedef enum
{
	CMODE_NORMAL,
	CMODE_DUALPF,
	CMODE_EXTRAHB,
	CMODE_HAM,
	CMODE_EXTRAHB_ECS_KILLEHB
} CMODE_T;

static void outindent(void)
{
	for (int i = 0; i < outfile_indent; i++) {
		fputc('\t', outfile);
	}
}
static void doindent(const char *s)
{
	if (strchr(s, '}') && strchr(s, '{')) {
		outfile_indent--;
		outindent();
		outfile_indent++;
	} else if (strchr(s, '}')) {
		outfile_indent--;
		outindent();
	} else if (strchr(s, '{')) {
		outindent();
		outfile_indent++;
	} else {
		outindent();
	}
}

static void outf(const char *s, ...)
{
	va_list ap;
	while (*s == ' ' || *s == '\t') {
		s++;
	}
	doindent(s);
	va_start(ap, s);
	vfprintf(outfile, s, ap);
	fprintf(outfile, "\n");
}

static void outln(const char *s)
{
	doindent(s);
	fprintf (outfile, "%s\n", s);
}

static void outlnf(const char *s, ...)
{
	va_list ap;
	while (*s == ' ' || *s == '\t') {
		s++;
	}
	doindent(s);
	va_start (ap, s);
	vfprintf (outfile, s, ap);
	fputc ('\n', outfile);
}

static void closefile(void)
{
	if (outfile) {
		fclose(outfile);
	}
	outfile = NULL;
}
static void set_outfile(const char *name)
{
	closefile();
	outfile = fopen(name, "w");
	outf("/*");
	outf(" * UAE - The portable Amiga emulator.");
	outf(" *");
	outf(" * This file was generated by genlinetoscr. Don't edit.");
	outf(" */");
	outf("");
}

static void gen_hdiw(void)
{
	if (!aga) {
		outf("if (cnt == denise_hstrt_lores) {");
		outf("	do_hstrt_ecs();");
		outf("}");
		outf("if (cnt == denise_hstop_lores) {");
		outf("	do_hstop_ecs();");
		outf("}");
	}
}
static void gen_hdiw_aga(int add)
{
	if (aga) {
		outf("if (cnt + %d == denise_hstrt) {", add);
		outf("	do_hstrt_aga();");
		outf("}");
		outf("if (cnt + %d == denise_hstop) {", add);
		outf("	do_hstop_aga();");
		outf("}");
	}
}

static void gen_hblank(int add)
{
	if (!aga) {
		outf("if (cnt == denise_hbstrt) {");
		outf("do_hbstrt();");
		outf("}");
		outf("if (cnt == denise_hbstop) {");
		outf("do_hbstop();");
		outf("}");
		outf("if (exthblankon_ecs) {");
		outf("do_exthblankon_ecs();");
		outf("}");
	} else {
		outf("if (cnt + %d == denise_hbstrt) {", add);
		outf("do_hbstrt();");
		outf("}");
		outf("if (cnt + %d == denise_hbstop) {", add);
		outf("do_hbstop();");
		outf("}");
		outf("if (cnt + %d == denise_phbstrt) {", add);
		outf("do_phbstrt_aga();");
		outf("}");
		outf("if (cnt + %d == denise_phbstop) {", add);
		outf("do_phbstop_aga();");
		outf("}");
	}
}

static void gen_bplpixmode_ecs(int num)
{
	switch (modes)
	{
		default:
		outf("dpix_val%d = denise_colors.acolors[pix%d];", num, num);
		if (genlock) {
			outf("gpix%d = get_genlock_transparency(pix%d);", num, num);
		}
		break;
		case CMODE_DUALPF:
		outf("uae_u8 val%d = dpf_lookup[pix%d];", num, num);
		outf("dpix_val%d = denise_colors.acolors[val%d];", num, num);
		if (genlock) {
			outf("gpix%d = get_genlock_transparency(dpf_lookup[pix%d]);", num, num);
		}
		break;
		case CMODE_EXTRAHB:
		outf("pix%d &= bplehb_mask;", num);
		outf("if (pix%d <= 31) {", num);
		outf("	dpix_val%d = denise_colors.acolors[pix%d];", num, num);
		outf("} else {");
		outf("	dpix_val%d = p_xcolors[(denise_colors.color_regs_ecs[pix%d - 32] >> 1) & 0x777];", num, num);
		outf("}");
		if (genlock) {
			outf("gpix%d = get_genlock_transparency(pix%d & 31);", num, num);
		}
		break;
		case CMODE_HAM:
		outf("dpix_val%d = decode_ham_pixel(pix%d);", num, num);
		if (genlock) {
			outf("gpix%d = get_genlock_transparency(pix%d & 15);", num, num);
		}
		break;
	}
}

static void gen_bplpixmode_aga(int num)
{
	switch (modes)
	{
		default:
		outf("dpix_val%d = denise_colors.acolors[pix%d ^ bplcon4_denise_xor_val];", num, num);
		if (genlock) {
			outf("gpix%d = get_genlock_transparency(pix%d ^ bplcon4_denise_xor_val);", num, num);
		}
		break;
		case CMODE_DUALPF:
		outf("uae_u8 val%d = dpf_lookup[pix%d];", num, num);
		outf("if (dpf_lookup_no[pix%d]) {", num);
		outf("	val%d += dblpfofs[bpldualpf2of];", num);
		outf("}");
		outf("val%d ^= bplcon4_denise_xor_val;", num);
		outf("dpix_val%d = denise_colors.acolors[val%d];", num, num);
		if (genlock) {
			outf("gpix%d = get_genlock_transparency(dpf_lookup[pix%d]);", num, num);
		}
		break;
		case CMODE_EXTRAHB:
		outf("pix%d ^= bplcon4_denise_xor_val;", num);
		outf("if (!(pix%d & 0x20)) {", num);
		outf("	dpix_val%d = denise_colors.acolors[pix%d];", num, num);
		outf("} else {");
		outf("	uae_u32 v = (denise_colors.color_regs_aga[pix%d & 0x1f] >> 1) & 0x7f7f7f;", num);
		outf("	dpix_val%d = CONVERT_RGB(v);", num);
		outf("}");
		if (genlock) {
			outf("gpix%d = get_genlock_transparency((pix%d ^ bplcon4_denise_xor_val) & 31);", num, num);
		}
		break;
		case CMODE_HAM :
		outf("dpix_val%d = decode_ham_pixel_aga(pix%d);", num, num);
		if (genlock) {
			if (planes == 8) {
				outf("gpix%d = get_genlock_transparency((pix%d >> 2) & 63);", num, num);
			} else {
				outf("gpix%d = get_genlock_transparency(pix%d & 15);", num, num);
			}
		}
		break;
		case CMODE_EXTRAHB_ECS_KILLEHB:
		outf("pix%d ^= bplcon4_denise_xor_val;", num);
		outf("dpix_val%d = denise_colors.acolors[pix%d & 31];", num, num);
		if (genlock) {
			outf("gpix%d = get_genlock_transparency((pix%d ^ bplcon4_denise_xor_val) & 31);", num, num);
		}
		break;
	}
}

static void gen_getbpl(int num, int maxplanes)
{
	if (modetype <= 0) {
		return;
	}

	int p = planes < maxplanes ? planes : maxplanes;
	if (bplfmode == 2) {
		outf("loaded_pix = getbpl%d_64();", p);
	} else if (bplfmode == 1) {
		outf("loaded_pix = getbpl%d_32(); ", p);
	} else if (aga) {
		outf("loaded_pix = getbpl%d();", p);
	} else {
		outf("pix%d = getbpl%d();", num, p);
	}
}

static void gen_shiftbpl(int maxplanes)
{
	if (modetype <= 0) {
		return;
	}

	int p = planes < maxplanes ? planes : maxplanes;
	if (bplfmode == 2) {
		outf("shiftbpl%d_64();", p);
	} else {
		outf("shiftbpl%d();", p);
	}
}

static void gen_shiftbpl_hr(int maxplanes)
{
	if (modetype <= 0) {
		return;
	}

	int p = planes < maxplanes ? planes : maxplanes;
	int add;
	if (outres > res) {
		add = 4 >> (outres - res);
	} else {
		add = 4;
	}
	if (add == 4) {
		if (bplfmode == 2) {
			outf("shiftbpl%d_64();", p);
		} else {
			outf("shiftbpl%d();", p);
		}
	} else if (oddeven) {
		outf("bplshiftcnt[0] += %d;", add);
		outf("if (bplshiftcnt[0] >= 4) {");
		outf("bplshiftcnt[0] = 0;");
		if (bplfmode == 2) {
			outf("shiftbpl%de_64();", p);
		} else {
			outf("shiftbpl%de();", p);
		}
		gen_getbpl(0, maxplanes);
		outf("}");
		outf("bplshiftcnt[1] += %d;", add);
		outf("if (bplshiftcnt[1] >= 4) {");
		outf("bplshiftcnt[1] = 0;");
		if (bplfmode == 2) {
			outf("shiftbpl%do_64();", p);
		} else {
			outf("shiftbpl%do();", p);
		}
		gen_getbpl(0, maxplanes);
		outf("}");
	} else {
		outf("bplshiftcnt[0] += %d;", add);
		outf("if (bplshiftcnt[0] >= 4) {");
		outf("bplshiftcnt[0] = 0;");
		if (bplfmode == 2) {
			outf("shiftbpl%d_64();", p);
		} else {
			outf("shiftbpl%d();", p);
		}
		gen_getbpl(0, maxplanes);
		outf("}");
	}
}


static void gen_shiftspr(int shift)
{
	if (aga) {
		outf("denise_shift_sprites_aga(%d);", shift);
	} else {
		//outf("denise_shift_sprites(%d);", shift);
	}
}

static void gen_ecsshresspr(void)
{
	outf("if (sv0 || sv1) {");
	outf("get_shres_spr_pix(sv0, sv1, &dpix_val0, &dpix_val2);");
	outf("if (sv0) {");
	outf("dpix_val1 = dpix_val0;");
	outf("}");
	outf("if (sv1) {");
	outf("dpix_val3 = dpix_val2;");
	outf("}");
	outf("}");
}

static void gen_sprpix(int i)
{
	// sprite pixel
	outf("uae_u32 sv%d = 0;", i);
	outf("if (denise_spr_nr_armeds) {");
	outf("	uae_u32 svt;");
	if (aga) {
		// outres > sprres ? 1 << (2 - (outres - sprres)) : 4
		outf("		svt = denise_render_sprites_aga(denise_spr_add);");
	} else if (ecsshres) {
		outf("		svt = denise_render_sprites_ecs_shres();");
	} else {
		outf("		svt = denise_render_sprites_lores();");
	}
	outf("	if (!denise_sprite_blank_active && !sprites_hidden) {");
	outf("	sv%d = svt;", i);
	outf("	}");
	outf("}");
}

static void gen_storepix(int off, int off2)
{
	// ultra extreme debugging blanking raster
	outf("#ifdef DEBUGGER");
	outf("	if (decode_specials_debug) {");
	outf("		dpix_val%d = decode_denise_specials_debug(dpix_val%d, cnt + %d);", off, off, off2);
	outf("	}");
	outf("#endif");

	outf("	*buf1++ = dpix_val%d;", off);
	outf("	*buf2++ = dpix_val%d;", off);
	if (genlock) {
		outf("	*gbuf++ = gpix%d;", off);
	}
}

static void gen_prepix(int i)
{
	outf("uae_u8 pix%d = 0;", i);
	if (genlock) {
		outf("uae_u8 gpix%d = 0xff;", i);
	}
	outf("uae_u32 dpix_val%d = BLANK_COLOR;", i);
}

static void gen_copybpl_lines(int oddeven)
{
	for (int i = 1; i <= 8; i++) {
		if (planes >= i) {
			if (oddeven == 0 || (oddeven == 1 && (i & 1)) || (oddeven == 2 && !(i & 1))) {
				if (bplfmode == 2) {
					outf("bplxdat3_64[%d] = bplxdat2_64[%d];", i - 1, i - 1);
				} else {
					outf("bplxdat3[%d] = bplxdat2[%d];", i - 1, i - 1);
				}
			}
		}
	}
	if (oddeven == 0 || oddeven == 1) {
		outf("bpldat_copy[0] = false;");
	}
	if (oddeven == 0 || oddeven == 2) {
		outf("bpldat_copy[1] = false;");
	}
}

static void gen_copybpl(void)
{
	if (modetype <= 0) {
		return;
	}
	
	if (oddeven) {
		// bitplane shifter shifting
		outf("if (bpldat_copy[0] && (denise_hcounter_cmp & %d) == bplcon1_shift[0]) { ", ((16 << bplfmode) >> res) - 1);
		if (bplfmode == 2) {
			outf("copybpl%de_64();", planes);
		} else {
			outf("copybpl%de();", planes);
		}
		outf("}");
		outf("if (bpldat_copy[1] && (denise_hcounter_cmp & %d) == bplcon1_shift[1]) {", ((16 << bplfmode) >> res) - 1);
		if (bplfmode == 2) {
			outf("copybpl%do_64();", planes);
		} else {
			outf("copybpl%do();", planes);
		}
		outf("}");
	} else {
		// bitplane shifter shifting
		outf("if (bpldat_copy[0] && (denise_hcounter_cmp & %d) == bplcon1_shift[0]) { ", ((16 << bplfmode) >> res) - 1);
		if (bplfmode == 2) {
			outf("copybpl%d_64();", planes);
		} else {
			outf("copybpl%d();", planes);
		}
		outf("}");
	}
}

static void gen_copybpl_hr(int add)
{
	if (modetype <= 0) {
		return;
	}

	int max;
	if (outres > res) {
		max = 1 << (outres - res);
	} else {
		max = 1;
	}
	if (oddeven) {
		// bitplane shifter shifting
		outf("if (bpldat_copy[0] && ((cmp | %d) & %d) == bplcon1_shift_full_masked[0]) { ", add, (((16 << bplfmode) >> res) << 2) - 1);
		if (bplfmode == 2) {
			outf("copybpl%de_64();", planes);
		} else {
			outf("copybpl%de();", planes);
		}
		if (max > 1) {
			outf("bplshiftcnt[0] = 0;");
			gen_getbpl(0, maxplanes);
		}
		outf("}");
		outf("if (bpldat_copy[1] && ((cmp | %d) & %d) == bplcon1_shift_full_masked[1]) {", add, (((16 << bplfmode) >> res) << 2) - 1);
		if (bplfmode == 2) {
			outf("copybpl%do_64();", planes);
		} else {
			outf("copybpl%do();", planes);
		}
		if (max > 1) {
			outf("bplshiftcnt[1] = 0;");
			gen_getbpl(0, maxplanes);
		}
		outf("}");
	} else {
		// bitplane shifter shifting
		outf("if (bpldat_copy[0] && ((cmp | %d) & %d) == bplcon1_shift_full_masked[0]) { ", add, (((16 << bplfmode) >> res) << 2) - 1);
		if (bplfmode == 2) {
			outf("copybpl%d_64();", planes);
		} else {
			outf("copybpl%d();", planes);
		}
		if (max > 1) {
			outf("bplshiftcnt[0] = 0;");
			gen_getbpl(0, maxplanes);
		}
		outf("}");
	}
	if (max == 1) {
		gen_getbpl(0, maxplanes);
	}
}

static void gen_matchspr(int i)
{
	// sprite X comparisons
	if (sprres >= 0) {
		if (aga) {
			outf("matchsprites_aga(cnt + %d);", i);
		} else {
			if (modetype > 0) {
				if (ecsshres) {
					outf("matchsprites_ecs_shres(cnt + %d);", i);
				} else {
					outf("matchsprites(cnt + %d);", i);
				}
			}
		}
	}
}

static void gen_sprmerge(int off, int k, int dbl)
{
	outf("if (sv%d) {", k);
	outf("	uae_u32 spix%d = denise_render_sprites2(pix%d, sv%d);", off, k, k);
	outf("	if (spix%d) {", off);
	outf("		dpix_val%d = denise_colors.acolors[spix%d];", off, off);
	if (genlock) {
		outf("gpix%d = get_genlock_transparency(spix%d);\n", off, off);
	}
	for (int i = 0; i < dbl - 1; i++) {
		outf("		dpix_val%d = dpix_val%d;", off + i + 1, off);
	}
	if (filtered) {
		outf("		dpix_val%d = dpix_val%d;", off + 1, off);
	}
	outf("	}");
	outf("}");
}


static void gen_pix_aga(void)
{
	int cnt = 0;
	int off = 0;
	for (int i = 0; i < (1 << outres); i++) {
		if (!i) {
			outf("if (checkhorizontal1_aga(denise_hcounter, denise_hcounter_next, h)) continue;");
		}

		gen_matchspr(off);

		// bitplane pixel
		gen_prepix(off);
		outf("if (!denise_blank_active) {");
		if (genlock) {
			outf("gpix%d = get_genlock_transparency_border();", off);
		}
		outf("	dpix_val%d = bordercolor;", off);
		if (modetype > 0) {
			outf("	if (denise_hdiw && bpl1dat_trigger) {");
			outf("	pix%d = loaded_pixs[%d];", off, off);
			outf("	clxdat |= bplcoltable[pix%d];", off);
			gen_bplpixmode_aga(off);
		}
		outf("	}");
		if (modetype > 0) {
			outf("	last_bpl_pix = pix%d;", off);
			outf("}");
			gen_shiftbpl_hr(maxplanes);
			gen_copybpl_hr(off);
		}

		if (sprres >= 0) {
			gen_sprpix(off);
			if (sprres > outres) {
				gen_shiftspr(sprres > outres + 1 ? 2 : 1);
			}
		}

		if (modetype > 0) {
			outf("loaded_pixs[%d] = loaded_pix;", off);
		}

		if (res > outres) {
			for (int i = 0; i < (1 << (res - outres)) - 1; i++) {
				off++;
				if (filtered) {
					gen_prepix(off);
					outf("if (!denise_blank_active) {");
					if (genlock) {
						outf("gpix%d = get_genlock_transparency_border();", off);
					}
					outf("	dpix_val%d = bordercolor;", off);
					if (modetype > 0) {
						outf("	if (denise_hdiw && bpl1dat_trigger) {");
						outf("	pix%d = loaded_pixs[%d];", off, off);
						outf("	clxdat |= bplcoltable[pix%d];", off);
						gen_bplpixmode_aga(off);
					}
					outf("	}");
					if (modetype > 0) {
						outf("	last_bpl_pix = pix%d;", off);
						outf("}");
						gen_shiftbpl_hr(maxplanes);
						gen_copybpl_hr(off);
						outf("loaded_pixs[%d] = loaded_pix;", off);
					}
				} else {
					// HAM special case, all pixels must be processed.
					if (modes == CMODE_HAM) {
						gen_prepix(off);
						outf("if (!denise_blank_active) {");
						outf("	dpix_val%d = bordercolor;", off);
						if (modetype > 0) {
							outf("	if (denise_hdiw && bpl1dat_trigger) {");
							outf("	pix%d = loaded_pixs[%d];", off, off);
							outf("	decode_ham_pixel_aga(pix%d);", off);
						}
						outf("}");
						if (modetype > 0) {
							outf("	last_bpl_pix = pix%d;", off);
							outf("}");
							gen_shiftbpl_hr(maxplanes);
							gen_copybpl_hr(off);
							outf("loaded_pixs[%d] = loaded_pix;", off);
						}
					} else {
						gen_shiftbpl(maxplanes);
					}
				}
			}
			off++;
		} else {
			off += 4 / (1 << outres);
		}
		outf("internal_pixel_cnt += %d;", 4 / (1 << outres));
	}

	outf("if (denise_pixtotal >= 0 && denise_pixtotal < denise_pixtotal_max) {");

	// bitplane/sprite merging
	off = 0;
	for (int i = 0; i < (1 << outres); i++) {
		if (sprres >= 0) {
			gen_sprmerge(off, off, 0);	
		}
		if (filtered) {
			outf("dpix_val%d = filter_pixel(dpix_val%d, dpix_val%d);", off, off, off + 1);
			if (genlock) {
				outf("gpix%d = filter_pixel_genlock(gpix%d, gpix%d);", off, off, off + 1);
			}
		}
		if (ntsc) {
			outf("dtbuf[h][%d] = dpix_val%d;", off, off);
			if (genlock) {
				outf("dtgbuf[h][%d] = gpix%d;", off, off);
			}
		}
		if (res > outres) {
			for (int i = 0; i < (1 << (res - outres - 1)); i++) {
				off++;
			}
			off++;
		} else {
			off += 4 / (1 << outres);
		}
	}

	off = 0;
	for (int i = 0; i < (1 << outres); i++) {

		// ultra extreme debugging blanking raster
		if (ntsc) {
			outf("uae_u32 t%d = dtbuf[h ^ lol][%d]; ", off, off);
		} else {
			outf("uae_u32 t%d = dpix_val%d; ", off, off);
		}
		outf("#ifdef DEBUGGER");
		outf("	if (decode_specials_debug) {");
		outf("		t%d = decode_denise_specials_debug(t%d, cnt + %d);", off, off, off);
		outf("	}");
		outf("#endif");
		outf("	*buf1++ = t%d;", off);
		outf("	*buf2++ = t%d;", off);
		if (genlock) {
			if (ntsc) {
				outf("	*gbuf++ = dtgbuf[h ^ lol][%d];", off, off);
			} else {
				outf("	*gbuf++ = gpix%d;", off, off);
			}
		}

		//gen_storepix(off, off);

		if (res > outres) {
			for (int i = 0; i < (1 << (res - outres - 1)); i++) {
				off++;
			}
			off++;
		} else {
			off += 4 / (1 << outres);
		}
	}

	outf("}");
}

static void gen_pix(void)
{
	int pixels = 1 << (outres > res ? outres : res);
	int hmax = pixels / (1 << outres);
	int bmax = pixels / (1 << res) - 1;
	int smax, smax2;

	int cnt = 0;
	int bcnt = bmax,hcnt = hmax;
	int pixt[4] = { 0 };
	int sprt[4] = { 0 };
	int lastspr = 0;

	smax = 0;
	smax2 = smax;
	int scnt = 0;

	outf("if (checkhorizontal1_ecs(denise_hcounter, denise_hcounter_next, h)) continue;");

	gen_matchspr(0);

	int off2o = -1;
	for (int i = 0; i < pixels; i++) {
		int off2 = i * (4 / (1 << outres));
		if (off2 != off2o) {
			hcnt = 0;
			off2o = off2;
		}
		if (bcnt++ >= bmax) {
			bcnt = 0;
			// bitplane pixel
			gen_prepix(i);
			outf("if (!denise_blank_active) {");
			if (genlock) {
				outf("gpix%d = get_genlock_transparency_border();", i);
			}
			outf("	dpix_val%d = bordercolor;", i);
			if (modetype > 0) {
				outf("	if (denise_hdiw && bpl1dat_trigger) {");
				gen_getbpl(i, maxplanes);
				outf("	clxdat |= bplcoltable[pix%d];", i);
				if (planes > 4) {
					outf("	if (decode_specials) {");
					outf("		pix%d = decode_denise_specials(pix%d);", i, i);
					outf("	}");
				}
				gen_bplpixmode_ecs(i);
				outf("	}");
				outf("	last_bpl_pix = pix%d;", i);
			}
			outf("}");
			gen_shiftbpl(maxplanes);
			pixt[i] = 1;
		}
		if (sprres >= 0 && modetype > 0) {
			if (!scnt) {
				scnt++;
				gen_sprpix(i);
				sprt[i] = 1;
				lastspr = i;
			}
		}
		int pix = pixels;
		while (pix < (1 << res)) {
			// shift skipped (display resolution < bitlane resolution) bitplane pixels
			gen_shiftbpl(maxplanes);
		   pix++;
		}
		outf("internal_pixel_cnt += %d;", 4 / pixels);
	}
	int pixcnt = 0;
	for (int i = 0; i < pixels; i++) {
		if (!pixt[i]) {
			outf("uae_u32 dpix_val%d = dpix_val%d;", i, i - 1);
			outf("uae_u8 pix%d = pix%d;", i, i - 1);
			if (genlock) {
				outf("uae_u8 gpix%d = gpix%d;", i, i - 1);
			}
			pixcnt++;
		}
	}

	outf("if (denise_pixtotal >= 0 && denise_pixtotal < denise_pixtotal_max) {");

	// bitplane/sprite merging
	for (int i = 0; i < (1 << outres); i++) {
		int off = i;
		if (res > outres) {
			off <<= (res - outres);
		}

		if (filtered) {
			outf("dpix_val%d = filter_pixel(dpix_val%d, dpix_val%d);", off, off, off + 1);
			if (genlock) {
				outf("gpix%d = filter_pixel_genlock(gpix%d, gpix%d);", off, off, off + 1);
			}
		}

		if (sprt[i]) {
			if (res == 0) {
				gen_sprmerge(off, 0, outres == 0 ? 0 : (outres == 1 ? 2 : 4));
			} else {
				for (int j = 0; j < (1 << outres); j++) {
					if (j > 0) {
						outf("uae_u32 sv%d = sv0;", j);
					}
					gen_sprmerge(off + j, j, 0);
				}
			}
		}
		if (ntsc) {
			outf("dtbuf[h][%d] = dpix_val%d;", off, off);
			if (genlock) {
				outf("dtgbuf[h][%d] = gpix%d;", off, off);
			}
		}
	}
	int j = 0, k = 0, jj = 0;
	for (int i = 0; i < (1 << outres); i++) {
		int off = i;
		if (res > outres) {
			off <<= (res - outres);
		}
		int off2 = i * (4 / (1 << outres));

		//gen_storepix(off, off2);

		// ultra extreme debugging blanking raster
		outf("uae_u32 t%d = 0;", off);
		outf("if (!extblank) {");
		if (ntsc) {
			outf("t%d = dtbuf[h ^ lol][%d]; ", off, off);
		} else {
			outf("t%d = dpix_val%d; ", off, off);
		}
		outf("}");
		outf("#ifdef DEBUGGER");
		outf("	if (decode_specials_debug) {");
		outf("		t%d = decode_denise_specials_debug(t%d, cnt + %d);", off, off, off2);
		outf("	}");
		outf("#endif");

		outf("	*buf1++ = t%d;", off);
		outf("	*buf2++ = t%d;", off);
		if (genlock) {
			if (ntsc) {
				outf("	*gbuf++ = dtgbuf[h ^ lol][%d];", off, off);
			} else {
				outf("	*gbuf++ = gpix%d;", off, off);
			}
		}

	}
	outf("}");

	gen_copybpl();
}

static void gen_init(void)
{
	if (aga) {
		outf("int cnt = denise_hcounter << 2;");
		outf("int cnt_next = denise_hcounter_next << 2;");
		if (modetype > 0) {
			outf("int cmp = denise_hcounter_cmp << 2;");
		}
	} else {
		outf("int cnt = denise_hcounter << 2;");
	}
}

static int gen_head(void)
{
	char funcname[200];

	sprintf(funcname, "lts_%s_%s_%s%d_p%d_i%s_d%s%s%s%s%s",
		aga ? "aga" : "ecs",
		bplfmode == 0 ? "fm0" : (bplfmode == 1 ? "fm1" : "fm2"),
		modes == 0 ? "n" : (modes == 1 ? "dpf" : (modes == 2 ? "ehb" : (modes == 4 ? "kehb" : "ham"))),
		oddeven ? 1 : 0,
		planes,
		res == 0 ? "lores" : (res == 1 ? "hires" : "shres"),
		outres == 0 ? "lores" : (outres == 1 ? "hires" : "shres"),
		sprres < 0 ? "" : "_spr",
		ntsc > 0 ? "_ntsc" : "",
		filtered > 0 ? "_filtered" : "",
		genlock ? "_genlock" : "");

	if (!filtered) {
		strcpy(funcnamep, funcname);
		funcnamep += strlen(funcnamep) + 1;
		*funcnamep = 0;
	} else {
		if (res <= outres) {
			strcpy(funcnamepf, " ");
			funcnamepf += strlen(funcnamepf) + 1;
			*funcnamepf = 0;
		} else {
			strcpy(funcnamepf, funcname);
			funcnamepf += strlen(funcnamepf) + 1;
			*funcnamepf = 0;
		}
	}

	outf("static void %s(void)", funcname);
	outf("{");

	if (filtered) {
		if (res <= outres) {
			return 0;
		}
	}

	// shres on lores is useless
	if (res == 2 && outres == 0) {
		return 0;
	}
	// skip non-existing modes
	if (!aga) {
		if (planes > 4 && res > 0) {
			return -1;
		}
		if (planes > 6) {
			return -1;
		}
		if (modes == CMODE_HAM && (res > 0 || planes <= 4)) {
			return -1;
		}
		if (planes != 6 && modes == CMODE_EXTRAHB) {
			return -1;
		}
	} else {
		if (modes == CMODE_HAM && (planes != 6 && planes != 8)) {
			return -1;
		}
		if (planes != 6 && (modes == CMODE_EXTRAHB || modes == CMODE_EXTRAHB_ECS_KILLEHB)) {
			return -1;
		}
		// FMODE=1: Superhires max 4 planes
		if (bplfmode == 1 && planes > 4 && res > 1) {
			return -1;
		}
		// FMODE=0: Hires max 4 planes.
		if (bplfmode == 0 && planes > 4 && res > 0) {
			return -1;
		}
		// FMODE=0: Superhires max 2 planes.
		if (bplfmode == 0 && planes > 2 && res > 1) {
			return -1;
		}
	}
	return 1;
}

static bool gen_fasthead(void)
{
	char funcname[200];
	sprintf(funcname, "lts_%s_%s_i%s_d%s_%s%s%s",
		aga ? "aga" : "ecs",
		modes == 0 ? "n" : (modes == 1 ? "dpf" : (modes == 2 ? "ehb" : (modes == 4 ? "kehb" : "ham"))),
		res == 0 ? "lores" : (res == 1 ? "hires" : "shres"),
		outres == 0 ? "lores" : (outres == 1 ? "hires" : "shres"),
		isbuf2 ? "b2" : "b1",
		filtered > 0 ? "_filtered" : "",
		genlock ? "_genlock" : "");

	if (!filtered) {
		strcpy(funcnamep, funcname);
		funcnamep += strlen(funcnamep) + 1;
		*funcnamep = 0;
	} else {
		if (res <= outres) {
			strcpy(funcnamepf, " ");
			funcnamepf += strlen(funcnamepf) + 1;
			*funcnamepf = 0;
		} else {
			strcpy(funcnamepf, funcname);
			funcnamepf += strlen(funcnamepf) + 1;
			*funcnamepf = 0;
		}
	}

	outf("static void %s(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,"
		"int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)", funcname);
	outf("{");

	// shres on lores is useless
	if (res == 2 && outres == 0) {
		return false;
	}

	if (filtered) {
		if (res <= outres) {
			return false;
		}
	}

	return true;
}

static void gen_fastdraw_drawmode_ecs(char *colname)
{
	if (modes == CMODE_DUALPF) {
		outf("{");
		outf("uae_u8 dpval = dpf_lookup[c];");
		outf("%s = acolors[dpval];", colname);
		outf("}");
	} else if (modes == CMODE_HAM) {
		outf("%s = decode_ham_pixel_fast(c, colors_ocs);", colname);
	} else if (modes == CMODE_EXTRAHB_ECS_KILLEHB) {
		outf("%s = acolors[c & 31];", colname);
	} else if (modes == CMODE_EXTRAHB) {
		outf("c &= bplehb_mask;");
		outf("if (c <= 31) {");
		outf("	%s = acolors[c];", colname);
		outf("} else {");
		outf("	%s = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];", colname);
		outf("}");
	} else {
		outf("%s = acolors[c];", colname);
	}
}

static void gen_fastdraw_drawmode_aga(char *colname)
{
	if (modes == CMODE_DUALPF) {
		outf("{");
		outf("uae_u8 dpval = dpf_lookup[c];");
		outf("if (dpf_lookup_no[c]) {");
		outf("	dpval += dblpfofs[bpldualpf2of];");
		outf("}");
		outf("dpval ^= bxor;");
		outf("%s = acolors[dpval];", colname);
		outf("}");
	} else if (modes == CMODE_HAM) {
		outf("%s = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);", colname);
	} else if (modes == CMODE_EXTRAHB_ECS_KILLEHB) {
		outf("c ^= bxor;");
		outf("%s = acolors[c & 31];", colname);
	} else if (modes == CMODE_EXTRAHB) {
		outf("c ^= bxor;");
		outf("if (c & 0x20) {");
		outf("	uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;");
		outf("	%s = CONVERT_RGB(v);", colname);
		outf("} else {");
		outf("	%s = acolors[c];", colname);
		outf("}");
	} else {
		outf("c ^= bxor;");
		outf("%s = acolors[c];", colname);
	}
}

static void gen_fastdraw_mode(int off, int total)
{
	int doubling = outres - res;

	if (aga) {
		outf("c = *cp;");
		outf("clxdat |= bplcoltable[c];");
		gen_fastdraw_drawmode_aga("col");
		if (doubling < 0) {
			outf("c = cp[1];");
			outf("clxdat |= bplcoltable[c];");
			if (filtered) {
				outf("uae_u32 colf;");
				gen_fastdraw_drawmode_aga("colf");
				outf("col = filter_pixel(col, colf);");
			} else {
				if (modes == CMODE_HAM) {
					outf("decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);");
				}
			}
		}
		outf("cp += cpadds[%d];", off);
	} else if (res == 2) { // ECS shres
		outf("uae_u8 c0 = *cp++;");
		outf("uae_u8 c1 = *cp++;");
		if (doubling == -2) {
			outf("cp += 2;");
		}
		outf("uae_u32 dpix_val0, dpix_val1;");
		if (genlock) {
			outf("uae_u8 gpix0, gpix1;");
			outf("get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);");
		} else {
			outf("get_shres_pix(c0, c1, &dpix_val0, &dpix_val1);");
		}
		if (doubling < 0) {
			outf("dpix_val0 = filter_pixel(dpix_val0, dpix_val1);");
			if (genlock) {
				outf("gpix0 = filter_pixel_genlock(gpix0, gpix1);");
			}
		}
		outf("*buf1++ = dpix_val0;");
		if (doubling == 0) {
			outf("*buf1++ = dpix_val1;");
		}
		if (isbuf2) {
			outf("*buf2++ = dpix_val0;");
			if (doubling == 0) {
				outf("*buf2++ = dpix_val1;");
			}
		}
		if (genlock) {
			outf("*gbuf++ = gpix0;");
			if (doubling == 0) {
				outf("*gbuf++ = gpix1;");
			}
		}
		if (doubling == 0) {
			outf("cnt += bufaddv;");
		}
		return;
	} else {
		outf("c = *cp;");
		outf("clxdat |= bplcoltable[c];");
		gen_fastdraw_drawmode_ecs("col");
		if (doubling < 0) {
			outf("c = cp[1];");
			outf("clxdat |= bplcoltable[c];");
			if (filtered) {
				outf("uae_u32 colf;");
				gen_fastdraw_drawmode_ecs("colf");
				outf("col = filter_pixel(col, colf);");
			}
		}
		if (off == total - 1) {
			outf("cp += cpaddv;");
		}
	}
	outf("*buf1++ = col;");
	if (isbuf2) {
		outf("*buf2++ = col;");
	}
	if (genlock) {
		outf("gpix = get_genlock_transparency_fast(c);");
		outf("*gbuf++ = gpix;");
	}
}

static void gen_fastdraw(void)
{
	int doubling = outres - res;

	outf("uae_u32 *acolors = (uae_u32*)ls->linecolorstate;");
	if (aga) {
		outf("uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));");
	} else {
		outf("uae_u16 *colors_ocs = (uae_u16*)(ls->linecolorstate + 256 * sizeof(uae_u32));");
	}
	if (aga) {
		outf("uae_u8 bxor = ls->bplcon4 >> 8;");
	}
	outf("int bufaddv = 1 << bufadd;");
	outf("int cpaddv = 1 << cpadd;");
	if (genlock) {
		outf("uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);");
	}

	outf("int end = draw_end;");
	outf("if (end > hbstrt_offset) {");
	outf("	end = hbstrt_offset;");
	outf("}");

	outf("int cnt = draw_end;");
	outf("if (cnt > draw_startoffset) {");
	outf("	cnt = draw_startoffset;");
	outf("}");
	outf("if (cnt > hbstop_offset) {");
	outf("	cnt = hbstop_offset;");
	outf("}");
	outf("if (cnt > bpl1dat_trigger_offset) {");
	outf("	cnt = bpl1dat_trigger_offset;");
	outf("}");

	outf("while (cnt < end) {");
	outf("	bool bpl = false;");
	outf("	if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {");
	outf("		if (cnt >= draw_startoffset) {");
	outf("		if (cnt < hbstop_offset) {");
	if (doubling <= 0) {
		outf("buf1++;");
		if (isbuf2) {
			outf("buf2++;");
		}
		if (genlock) {
			outf("gbuf++;");
		}
	} else if (doubling == 1)  {
		outf("buf1 += 2;");
		if (isbuf2) {
			outf("buf2 += 2;");
		}
		if (genlock) {
			outf("gbuf += 2;");
		}
	} else if (doubling == 2) {
		outf("buf1 += 4;");
		if (isbuf2) {
			outf("buf2 += 4;");
		}
		if (genlock) {
			outf("gbuf += 4;");
		}
	}
	outf("		} else {");
	if (doubling <= 0) {
		outf("*buf1++ = bgcolor;");
		if (isbuf2) {
			outf("*buf2++ = bgcolor;");
		}
		if (genlock) {
			outf("*gbuf++ = gpix;");
		}
	} else if (doubling == 1) {
		outf("*buf1++ = bgcolor;");
		outf("*buf1++ = bgcolor;");
		if (isbuf2) {
			outf("*buf2++ = bgcolor;");
			outf("*buf2++ = bgcolor;");
		}
		if (genlock) {
			outf("*gbuf++ = gpix;");
			outf("*gbuf++ = gpix;");
		}
	} else if (doubling == 2) {
		outf("*buf1++ = bgcolor;");
		outf("*buf1++ = bgcolor;");
		outf("*buf1++ = bgcolor;");
		outf("*buf1++ = bgcolor;");
		if (isbuf2) {
			outf("*buf2++ = bgcolor;");
			outf("*buf2++ = bgcolor;");
			outf("*buf2++ = bgcolor;");
			outf("*buf2++ = bgcolor;");
		}
		if (genlock) {
			outf("*gbuf++ = gpix;");
			outf("*gbuf++ = gpix;");
			outf("*gbuf++ = gpix;");
			outf("*gbuf++ = gpix;");
		}
	}
	outf("}");
	outf("	}");
	outf("} else {");
	outf("bpl = true;");
	if (res < 2 || aga) {
		outf("uae_u8 c;");
		outf("uae_u32 col;");
	}
	if (doubling <= 0) {
		gen_fastdraw_mode(0, 1);
	} else if (doubling == 1) {
		gen_fastdraw_mode(0, 2);
		gen_fastdraw_mode(1, 2);
	} else if (doubling == 2) {
		gen_fastdraw_mode(0, 4);
		gen_fastdraw_mode(1, 4);
		gen_fastdraw_mode(2, 4);
		gen_fastdraw_mode(3, 4);
	}
	outf("}");
	outf("if (cnt >= bpl1dat_trigger_offset && !bpl) {");
	outf("	cp += cpaddv;");
	outf("}");
	outf("cnt += bufaddv;");
	outf("}");
}

static void gen_null(void)
{
	outf("lts_null();");
}

static void gen_start(void)
{
	outf("	while (denise_cck < denise_endcycle) {");
	outf("		do_denise_cck(denise_linecnt, denise_startpos, denise_cck);");
	outf("      if (lts_changed) return;");
	outf("		for (int h = 0; h < 2; h++) {");
	outf("			if (h) {");
	outf("				denise_hcounter_next = denise_hcounter_new;");
	outf("			}");

}
static void gen_end(void)
{
	outf("			sprites_hidden = sprites_hidden2;");
	outf("#ifdef DEBUGGER");
	outf("			*debug_dma_dhpos_odd = denise_hcounter;");
	outf("#endif");
	outf("			denise_hcounter_cmp++;");
	outf("			denise_hcounter_cmp &= 511;");
	outf("			denise_hcounter++;");
	outf("			denise_hcounter &= 511;");
	outf("			denise_hcounter_next++;");
	outf("			denise_hcounter_next &= 511;");
	outf("		}");
	outf("		denise_pixtotal++;");
	outf("		if (denise_pixtotal == 0) {");
	outf("			internal_pixel_start_cnt = internal_pixel_cnt;");
	outf("		}");
	outf("		denise_hcounter = denise_hcounter_new;");
	outf("      if (denise_accurate_mode) {");
	outf("			denise_hcounter_cmp = denise_hcounter_new;");
	outf("		}");
	outf("		denise_cck++;");
	outf("	}");
}

static void gen_tail(void)
{
	outf("}");
}

static void helperfunctions(void)
{
	char *oddeven[] = { "", "e", "o" };

	for (int fmode = 0; fmode < 2; fmode++) {
		for (int i = 1; i <= 8; i++) {
			for (int oe = 0; oe < 3; oe++) {
				outf("STATIC_INLINE void shiftbpl%d%s%s(void)", i, oddeven[oe], fmode ? "_64" : "");
				outf("{");
				for (int j = oe == 2 ? 1 : 0; j < i; j += (oe == 0) ? 1 : 2) {
					if (fmode) {
						outf("bplxdat3_64[%d] <<= 1;", j);
					} else {
						outf("bplxdat3[%d] <<= 1;", j);
					}
				}
				outf("}");
			}
		}
	}
	for (int fmode = 0; fmode < 3; fmode++) {
		for (int i = 1; i <= 8; i++) {
			outf("STATIC_INLINE uae_u8 getbpl%d%s(void)", i, fmode == 1 ? "_32" : (fmode == 2 ? "_64" : ""));
			outf("{");
			outf("	uae_u8 v = 0;");
			for (int j = 0; j < i; j++) {
				if (fmode == 0) {
					outf("v |= ((bplxdat3[%d] >> 15) & 1) << %d;", j, j);
				} else if (fmode == 1) {
					outf("v |= ((bplxdat3[%d] >> 31) & 1) << %d;", j, j);
				} else {
					outf("v |= ((bplxdat3_64[%d] >> 63) & 1) << %d;", j, j);
				}
			}
			outf("	return v;");
			outf("}");
		}
	}
	for (int fmode = 0; fmode < 2; fmode++) {
		for (int k = 0; k < 3; k++) {
			for (int i = 1; i <= 8; i++) {
				outf("STATIC_INLINE void copybpl%d%s%s(void)", i, k == 0 ? "" : (k == 1 ? "e" : "o"), fmode ? "_64" : "");
				outf("{");
				int start = k <= 1 ? 0 : 1;
				int step = k >= 1 ? 2 : 1;
				for (int j = start; j < i; j += step) {
					outf("	if (denise_planes >= %d) {", j + 1);
					if (fmode) {
						outf("		bplxdat3_64[%d] = bplxdat2_64[%d];", j, j);
					} else {
						outf("		bplxdat3[%d] = bplxdat2[%d];", j, j);
					}
					outf("	}");
				}
				if (k > 0) {
					outf("	bpldat_copy[%d] = false;", k - 1);
				} else {
					outf("	bpldat_copy[0] = false;");
					outf("	bpldat_copy[1] = false;");
				}
				outf("}");
			}
		}
	}
}

static void write_funcs(const char *name)
{
	outf("static LINETOSRC_FUNC %s[] = {", name);
	char *p = funcnames;
	while (*p) {
		outf("%s,", p);
		p += strlen(p) + 1;
	}
	outf("NULL");
	outf("};");

	funcnamep = funcnames;
	*funcnamep = 0;

	outf("static LINETOSRC_FUNC %s_filtered[] = {", name);
	p = funcnamesf;
	while (*p) {
		if (p[0] == ' ') {
			outf("NULL,");
		} else {
			outf("%s,", p);
		}
		p += strlen(p) + 1;
	}
	outf("NULL");
	outf("};");

	funcnamepf = funcnamesf;
	*funcnamepf = 0;
}

static void write_funcs_fast(const char *name)
{
	outf("static LINETOSRC_FUNCF %s[] = {", name);
	char *p = funcnames;
	while (*p) {
		outf("%s,", p);
		p += strlen(p) + 1;
	}
	outf("NULL");
	outf("};");

	funcnamep = funcnames;
	*funcnamep = 0;

	outf("static LINETOSRC_FUNCF %s_filtered[] = {", name);
	p = funcnamesf;
	while (*p) {
		if (p[0] == ' ') {
			outf("NULL,");
		} else {
			outf("%s,", p);
		}
		p += strlen(p) + 1;
	}
	outf("NULL");
	outf("};");

	funcnamepf = funcnamesf;
	*funcnamepf = 0;
}

int main (int argc, char *argv[])
{
	set_outfile("../../linetoscr_common.cpp");

	helperfunctions();

	// AGA

	funcnamep = funcnames;
	*funcnamep = 0;
	funcnamepf = funcnamesf;
	*funcnamepf = 0;
	aga = 1;
	oddeven = 1;
	genlock = 0;
	ntsc = -1;
	modetype = 0;

	for (bplfmode = 0; bplfmode < 3; bplfmode++) {

		char tmp[100];
		sprintf(tmp, "../../linetoscr_aga_fm%d.cpp", bplfmode);
		set_outfile(tmp);

		for (outres = 0; outres < 3; outres++) {
			for (res = 0; res < 3; res++) {
				for (int spr = 0; spr < 2; spr++) {
					sprres = spr == 0 ? -1 : 0;
					for (planes = 2; planes <= 8; planes += 2) {
						for (modes = 0; modes < 5; modes++) {
							for (oddeven = 0; oddeven < 2; oddeven++) {
								modetype = gen_head();
								if (modetype) {
									gen_start();
									gen_init();
									gen_pix_aga();
									gen_end();
								} else {
									gen_null();
								}
								gen_tail();
								filtered = 1;
								modetype = gen_head();
								if (modetype) {
									gen_start();
									gen_init();
									gen_pix_aga();
									gen_end();
								} else {
									gen_null();
								}
								gen_tail();
								filtered = 0;
							}
						}
					}
				}
			}
		}
	}

	write_funcs("linetoscr_aga_funcs");

	genlock = 1;

	for (bplfmode = 0; bplfmode < 3; bplfmode++) {

		char tmp[100];
		sprintf(tmp, "../../linetoscr_aga_fm%d_genlock.cpp", bplfmode);
		set_outfile(tmp);

		for (outres = 0; outres < 3; outres++) {
			for (res = 0; res < 3; res++) {
				for (int spr = 0; spr < 2; spr++) {
					sprres = spr == 0 ? -1 : 0;
					for (planes = 4; planes <= 8; planes += 4) {
						for (modes = 0; modes < 5; modes++) {
							for (oddeven = 0; oddeven < 2; oddeven++) {
								modetype = gen_head();
								if (modetype) {
									gen_start();
									gen_init();
									gen_pix_aga();
									gen_end();
								} else {
									gen_null();
								}
								gen_tail();
								filtered = 1;
								modetype = gen_head();
								if (modetype) {
									gen_start();
									gen_init();
									gen_pix_aga();
									gen_end();
								} else {
									gen_null();
								}
								gen_tail();
								filtered = 0;
							}
						}
					}
				}
			}
		}
	}

	write_funcs("linetoscr_aga_genlock_funcs");

	// OCS/ECS
	set_outfile("../../linetoscr_ocs_ecs.cpp");

	aga = 0;
	bplfmode = 0;
	genlock = 0;
	ntsc = 0;

	const int planecnts[] = { 2, 4, 5, 6, 0 };
	for (outres = 0; outres < 3; outres++) {
		for (res = 0; res < 2; res++) {
			for (int spr = 0; spr < 2; spr++) {
				sprres = spr == 0 ? -1 : 0;
				for (int pc = 0; planecnts[pc]; pc++) {
					planes = planecnts[pc];
					for (modes = 0; modes < 4; modes++) {
						for (oddeven = 0; oddeven < 2; oddeven++) {
							modetype = gen_head();
							if (modetype) {
								gen_start();
								gen_init();
								gen_pix();
								gen_end();
							} else {
								gen_null();
							}
							gen_tail();
							filtered = 1;
							modetype = gen_head();
							if (modetype) {
								gen_start();
								gen_init();
								gen_pix();
								gen_end();
							} else {
								gen_null();
							}
							gen_tail();
							filtered = 0;
						}
					}
				}
			}
		}
	}

	write_funcs("linetoscr_ecs_funcs");

	// OCS/ECS genlock
	set_outfile("../../linetoscr_ocs_ecs_genlock.cpp");

	genlock = 1;

	for (outres = 0; outres < 3; outres++) {
		for (res = 0; res < 2; res++) {
			if (res > 0) {
				planes = 4;
			} else {
				planes = 6;
			}
			for (int spr = 0; spr < 2; spr++) {
				sprres = spr == 0 ? -1 : 0;
				for (modes = 0; modes < 4; modes++) {
					for (oddeven = 0; oddeven < 2; oddeven++) {
						modetype = gen_head();
						if (modetype) {
							gen_start();
							gen_init();
							gen_pix();
							gen_end();
						} else {
							gen_null();
						}
						gen_tail();
						filtered = 1;
						modetype = gen_head();
						if (modetype) {
							gen_start();
							gen_init();
							gen_pix();
							gen_end();
						} else {
							gen_null();
						}
						gen_tail();
						filtered = 0;
					}
				}
			}
		}
	}

	write_funcs("linetoscr_ecs_genlock_funcs");

	// OCS/ECS NTSC
	set_outfile("../../linetoscr_ocs_ecs_ntsc.cpp");

	aga = 0;
	bplfmode = 0;
	genlock = 0;
	ntsc = 1;

	for (outres = 0; outres < 3; outres++) {
		for (res = 0; res < 2; res++) {
			for (int spr = 0; spr < 2; spr++) {
				sprres = spr == 0 ? -1 : 0;
				for (int pc = 0; planecnts[pc]; pc++) {
					planes = planecnts[pc];
					for (modes = 0; modes < 4; modes++) {
						for (oddeven = 0; oddeven < 2; oddeven++) {
							modetype = gen_head();
							if (modetype) {
								gen_start();
								gen_init();
								gen_pix();
								gen_end();
							} else {
								gen_null();
							}
							gen_tail();
							filtered = 1;
							modetype = gen_head();
							if (modetype) {
								gen_start();
								gen_init();
								gen_pix();
								gen_end();
							} else {
								gen_null();
							}
							gen_tail();
							filtered = 0;
						}
					}
				}
			}
		}
	}

	write_funcs("linetoscr_ecs_ntsc_funcs");

	// OCS/ECS genlock NTSC
	set_outfile("../../linetoscr_ocs_ecs_ntsc_genlock.cpp");

	genlock = 1;

	for (outres = 0; outres < 3; outres++) {
		for (res = 0; res < 2; res++) {
			if (res > 0) {
				planes = 4;
			} else {
				planes = 6;
			}
			for (int spr = 0; spr < 2; spr++) {
				sprres = spr == 0 ? -1 : 0;
				for (modes = 0; modes < 4; modes++) {
					for (oddeven = 0; oddeven < 2; oddeven++) {
						modetype = gen_head();
						if (modetype) {
							gen_start();
							gen_init();
							gen_pix();
							gen_end();
						} else {
							gen_null();
						}
						gen_tail();
						filtered = 1;
						modetype = gen_head();
						if (modetype) {
							gen_start();
							gen_init();
							gen_pix();
							gen_end();
						} else {
							gen_null();
						}
						gen_tail();
						filtered = 0;
					}
				}
			}
		}
	}

	write_funcs("linetoscr_ecs_ntsc_genlock_funcs");

	// ECS SuperHires
	set_outfile("../../linetoscr_ecs_shres.cpp");

	modetype = 1;
	planes = 2;
	res = 2;
	modes = 0;
	oddeven = 0;
	ecsshres = 1;
	ntsc = -1;

	for (genlock = 0; genlock < 2; genlock++) {
		for (outres = 1; outres < 3; outres++) {
			for(filtered = 0; filtered < 2;filtered++) {
				if (filtered && outres != 1) {
					continue;
				}
				char funcname[200];
				sprintf(funcname, "lts_ecs_shres_d%s%s", 
					outres == 0 ? "lores" : (outres == 1 ? "hires" : "shres"),
					genlock ? "_genlock" : "");
				strcpy(funcnamep, funcname);
				funcnamep += strlen(funcnamep) + 1;
				*funcnamep = 0;
				if (filtered) {
					strcat(funcname, "_filtered");
				}
				outf("static void %s(void)", funcname);
				outf("{");
				gen_start();
				gen_init();
				gen_prepix(0);
				gen_prepix(1);
				gen_prepix(2);
				gen_prepix(3);
				outf("bool shifted = false;");
				outf("checkhorizontal1_ecs(denise_hcounter, denise_hcounter_next, h);");
				outf("if (!denise_blank_active) {");
				outf("	dpix_val0 = bordercolor_ecs_shres;");
				outf("	dpix_val1 = bordercolor_ecs_shres;");
				outf("	dpix_val2 = bordercolor_ecs_shres;");
				outf("	dpix_val3 = bordercolor_ecs_shres;");
				outf("	if (denise_hdiw && bpl1dat_trigger) {");
				outf("  shifted = true;");
				outf("pix0 = getbpl2();");
				outf("shiftbpl2();");
				outf("pix1 = getbpl2();");
				outf("shiftbpl2();");
				outf("pix2 = getbpl2();");
				outf("shiftbpl2();");
				outf("pix3 = getbpl2();");
				outf("shiftbpl2();");
				if (genlock) {
					outf("get_shres_pix_genlock(pix0, pix1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);");
					outf("get_shres_pix_genlock(pix2, pix3, &dpix_val2, &dpix_val3, &gpix2, &gpix3);");
				} else {
					outf("get_shres_pix(pix0, pix1, &dpix_val0, &dpix_val1);");
					outf("get_shres_pix(pix2, pix3, &dpix_val2, &dpix_val3);");
				}
				outf("}");
				outf("}");
				if (outres == 1) {
					gen_sprpix(0);
					gen_matchspr(0);
					gen_sprpix(1);
					gen_matchspr(2);
					gen_ecsshresspr();
					outf("if (denise_pixtotal >= 0 && denise_pixtotal < denise_pixtotal_max) {");
					if (filtered) {
						outf("dpix_val0 = filter_pixel(dpix_val0, dpix_val1);");
						outf("dpix_val2 = filter_pixel(dpix_val2, dpix_val3);");
						if (genlock) {
							outf("gpix0 = filter_pixel_genlock(gpix0, gpix1);");
							outf("gpix2 = filter_pixel_genlock(gpix2, gpix3);");
						}
					}
					gen_storepix(0, 0);
					gen_storepix(2, 2);
					outf("}");
				} else if (outres == 2) {
					gen_sprpix(0);
					gen_matchspr(0);
					gen_sprpix(1);
					gen_matchspr(2);
					gen_ecsshresspr();
					outf("if (denise_pixtotal >= 0 && denise_pixtotal < denise_pixtotal_max) {");
					gen_storepix(0, 0);
					gen_storepix(1, 1);
					gen_storepix(2, 2);
					gen_storepix(3, 3);
					outf("}");
				}
				outf("if (!shifted) {");
				outf("shiftbpl2();");
				outf("shiftbpl2();");
				outf("shiftbpl2();");
				outf("shiftbpl2();");
				outf("}");
				gen_copybpl();
				outf("internal_pixel_cnt += 4;");
				gen_end();
				gen_tail();
			}
		}

		write_funcs(genlock ? "linetoscr_ecs_shres_genlock_funcs" : "linetoscr_ecs_shres_funcs");
	}

	// fast drawing
	filtered = 0;
	genlock = 0;

	set_outfile("../../linetoscr_ecs_fast.cpp");
	aga = 0;
	bplfmode = 3;
	planes = 1;
	for (isbuf2 = 0; isbuf2 < 2; isbuf2++) {
		for (outres = 0; outres < 3; outres++) {
			for (res = 0; res < 3; res++) {
				for (modes = 0; modes < 5; modes++) {
					if (gen_fasthead()) {
						gen_fastdraw();
					} else {
						gen_null();
					}
					gen_tail();
					filtered = 1;
					if (gen_fasthead()) {
						gen_fastdraw();
					} else {
						gen_null();
					}
					gen_tail();
					filtered = 0;
				}
			}
		}
	}
	write_funcs_fast("linetoscr_ecs_fast_funcs");

	set_outfile("../../linetoscr_aga_fast.cpp");
	aga = 1;
	for (isbuf2 = 0; isbuf2 < 2; isbuf2++) {
		for (outres = 0; outres < 3; outres++) {
			for (res = 0; res < 3; res++) {
				for (modes = 0; modes < 5; modes++) {
					if (gen_fasthead()) {
						gen_fastdraw();
					} else {
						gen_null();
					}
					gen_tail();
					filtered = 1;
					if (gen_fasthead()) {
						gen_fastdraw();
					} else {
						gen_null();
					}
					gen_tail();
					filtered = 0;
				}
			}
		}
	}
	write_funcs_fast("linetoscr_aga_fast_funcs");

	genlock = 1;

	set_outfile("../../linetoscr_ecs_genlock_fast.cpp");
	aga = 0;
	bplfmode = 3;
	planes = 1;
	for (isbuf2 = 0; isbuf2 < 2; isbuf2++) {
		for (outres = 0; outres < 3; outres++) {
			for (res = 0; res < 3; res++) {
				for (modes = 0; modes < 5; modes++) {
					if (gen_fasthead()) {
						gen_fastdraw();
					} else {
						gen_null();
					}
					gen_tail();
					filtered = 1;
					if (gen_fasthead()) {
						gen_fastdraw();
					} else {
						gen_null();
					}
					gen_tail();
					filtered = 0;
				}
			}
		}
	}
	write_funcs_fast("linetoscr_ecs_genlock_fast_funcs");

	set_outfile("../../linetoscr_aga_genlock_fast.cpp");
	aga = 1;
	for (isbuf2 = 0; isbuf2 < 2; isbuf2++) {
		for (outres = 0; outres < 3; outres++) {
			for (res = 0; res < 3; res++) {
				for (modes = 0; modes < 5; modes++) {
					if (gen_fasthead()) {
						gen_fastdraw();
					} else {
						gen_null();
					}
					gen_tail();
					filtered = 1;
					if (gen_fasthead()) {
						gen_fastdraw();
					} else {
						gen_null();
					}
					gen_tail();
					filtered = 0;
				}
			}
		}
	}
	write_funcs_fast("linetoscr_aga_genlock_fast_funcs");


	closefile();

	return 0;
}
