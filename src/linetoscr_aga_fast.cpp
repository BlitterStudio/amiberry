/*
* UAE - The portable Amiga emulator.
*
* This file was generated by genlinetoscr. Don't edit.
*/

static void lts_aga_n_ilores_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ilores_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ilores_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ilores_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ilores_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ilores_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ilores_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ilores_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ilores_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ilores_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ihires_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ihires_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			c ^= bxor;
			colf = acolors[c];
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				colf = acolors[dpval];
			}
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				colf = CONVERT_RGB(v);
			} else {
				colf = acolors[c];
			}
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			c = cp[1];
			clxdat |= bplcoltable[c];
			decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			colf = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			c ^= bxor;
			colf = acolors[c & 31];
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ishres_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ishres_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ishres_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ishres_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ishres_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ishres_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ishres_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ishres_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ishres_dlores_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ishres_dlores_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ilores_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[1];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ilores_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ilores_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[1];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ilores_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ilores_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[1];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ilores_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ilores_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[1];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ilores_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ilores_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[1];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ilores_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ihires_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ihires_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ihires_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ihires_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ihires_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ihires_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ishres_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ishres_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			c ^= bxor;
			colf = acolors[c];
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ishres_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ishres_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				colf = acolors[dpval];
			}
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ishres_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ishres_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				colf = CONVERT_RGB(v);
			} else {
				colf = acolors[c];
			}
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ishres_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			c = cp[1];
			clxdat |= bplcoltable[c];
			decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ishres_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			colf = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ishres_dhires_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ishres_dhires_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			c ^= bxor;
			colf = acolors[c & 31];
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ilores_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[1];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[2];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[3];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ilores_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ilores_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[1];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[2];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[3];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ilores_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ilores_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[1];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[2];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[3];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ilores_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ilores_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[1];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[2];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[3];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ilores_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ilores_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[1];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[2];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[3];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ilores_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ihires_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[1];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ihires_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ihires_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[1];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ihires_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[1];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ihires_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[1];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ihires_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[0];
			*buf1++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[1];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ishres_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ishres_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ishres_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ishres_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ishres_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ishres_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ishres_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ishres_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ishres_dshres_b1(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
				} else {
					*buf1++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[0];
			*buf1++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ishres_dshres_b1_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ilores_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ilores_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ilores_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ilores_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ilores_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ilores_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ilores_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ilores_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ilores_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ilores_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ihires_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ihires_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			c ^= bxor;
			colf = acolors[c];
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				colf = acolors[dpval];
			}
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				colf = CONVERT_RGB(v);
			} else {
				colf = acolors[c];
			}
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			c = cp[1];
			clxdat |= bplcoltable[c];
			decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			colf = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			c ^= bxor;
			colf = acolors[c & 31];
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ishres_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ishres_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ishres_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ishres_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ishres_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ishres_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ishres_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ishres_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ishres_dlores_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ishres_dlores_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ilores_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ilores_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ilores_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ilores_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ilores_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ilores_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ilores_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ilores_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ilores_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ilores_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ihires_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ihires_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ihires_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ihires_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ihires_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ihires_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ishres_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ishres_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			c ^= bxor;
			colf = acolors[c];
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ishres_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ishres_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				colf = acolors[dpval];
			}
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ishres_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ishres_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				colf = CONVERT_RGB(v);
			} else {
				colf = acolors[c];
			}
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ishres_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			c = cp[1];
			clxdat |= bplcoltable[c];
			decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ishres_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			colf = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ishres_dhires_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			c = cp[1];
			clxdat |= bplcoltable[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ishres_dhires_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			c = cp[1];
			clxdat |= bplcoltable[c];
			uae_u32 colf;
			c ^= bxor;
			colf = acolors[c & 31];
			col = filter_pixel(col, colf);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ilores_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[2];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[3];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ilores_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ilores_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[2];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[3];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ilores_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ilores_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[2];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[3];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ilores_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ilores_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[2];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[3];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ilores_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ilores_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[2];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[3];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ilores_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ihires_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ihires_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ihires_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ihires_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ihires_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ihires_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[1];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_n_ishres_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ishres_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_dpf_ishres_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = acolors[dpval];
			}
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ishres_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ehb_ishres_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = acolors[c];
			}
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ishres_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_ham_ishres_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ishres_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_aga_kehb_ishres_dshres_b2(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *acolors = (uae_u32*)ls->linecolorstate;
	uae_u32 *colors_aga = (uae_u32*)(ls->linecolorstate + 256 * sizeof(uae_u32));
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c ^= bxor;
			col = acolors[c & 31];
			cp += cpadds[0];
			*buf1++ = col;
			*buf2++ = col;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ishres_dshres_b2_filtered(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static LINETOSRC_FUNCF linetoscr_aga_fast_funcs[] = {
	lts_aga_n_ilores_dlores_b1,
	lts_aga_dpf_ilores_dlores_b1,
	lts_aga_ehb_ilores_dlores_b1,
	lts_aga_ham_ilores_dlores_b1,
	lts_aga_kehb_ilores_dlores_b1,
	lts_aga_n_ihires_dlores_b1,
	lts_aga_dpf_ihires_dlores_b1,
	lts_aga_ehb_ihires_dlores_b1,
	lts_aga_ham_ihires_dlores_b1,
	lts_aga_kehb_ihires_dlores_b1,
	lts_aga_n_ishres_dlores_b1,
	lts_aga_dpf_ishres_dlores_b1,
	lts_aga_ehb_ishres_dlores_b1,
	lts_aga_ham_ishres_dlores_b1,
	lts_aga_kehb_ishres_dlores_b1,
	lts_aga_n_ilores_dhires_b1,
	lts_aga_dpf_ilores_dhires_b1,
	lts_aga_ehb_ilores_dhires_b1,
	lts_aga_ham_ilores_dhires_b1,
	lts_aga_kehb_ilores_dhires_b1,
	lts_aga_n_ihires_dhires_b1,
	lts_aga_dpf_ihires_dhires_b1,
	lts_aga_ehb_ihires_dhires_b1,
	lts_aga_ham_ihires_dhires_b1,
	lts_aga_kehb_ihires_dhires_b1,
	lts_aga_n_ishres_dhires_b1,
	lts_aga_dpf_ishres_dhires_b1,
	lts_aga_ehb_ishres_dhires_b1,
	lts_aga_ham_ishres_dhires_b1,
	lts_aga_kehb_ishres_dhires_b1,
	lts_aga_n_ilores_dshres_b1,
	lts_aga_dpf_ilores_dshres_b1,
	lts_aga_ehb_ilores_dshres_b1,
	lts_aga_ham_ilores_dshres_b1,
	lts_aga_kehb_ilores_dshres_b1,
	lts_aga_n_ihires_dshres_b1,
	lts_aga_dpf_ihires_dshres_b1,
	lts_aga_ehb_ihires_dshres_b1,
	lts_aga_ham_ihires_dshres_b1,
	lts_aga_kehb_ihires_dshres_b1,
	lts_aga_n_ishres_dshres_b1,
	lts_aga_dpf_ishres_dshres_b1,
	lts_aga_ehb_ishres_dshres_b1,
	lts_aga_ham_ishres_dshres_b1,
	lts_aga_kehb_ishres_dshres_b1,
	lts_aga_n_ilores_dlores_b2,
	lts_aga_dpf_ilores_dlores_b2,
	lts_aga_ehb_ilores_dlores_b2,
	lts_aga_ham_ilores_dlores_b2,
	lts_aga_kehb_ilores_dlores_b2,
	lts_aga_n_ihires_dlores_b2,
	lts_aga_dpf_ihires_dlores_b2,
	lts_aga_ehb_ihires_dlores_b2,
	lts_aga_ham_ihires_dlores_b2,
	lts_aga_kehb_ihires_dlores_b2,
	lts_aga_n_ishres_dlores_b2,
	lts_aga_dpf_ishres_dlores_b2,
	lts_aga_ehb_ishres_dlores_b2,
	lts_aga_ham_ishres_dlores_b2,
	lts_aga_kehb_ishres_dlores_b2,
	lts_aga_n_ilores_dhires_b2,
	lts_aga_dpf_ilores_dhires_b2,
	lts_aga_ehb_ilores_dhires_b2,
	lts_aga_ham_ilores_dhires_b2,
	lts_aga_kehb_ilores_dhires_b2,
	lts_aga_n_ihires_dhires_b2,
	lts_aga_dpf_ihires_dhires_b2,
	lts_aga_ehb_ihires_dhires_b2,
	lts_aga_ham_ihires_dhires_b2,
	lts_aga_kehb_ihires_dhires_b2,
	lts_aga_n_ishres_dhires_b2,
	lts_aga_dpf_ishres_dhires_b2,
	lts_aga_ehb_ishres_dhires_b2,
	lts_aga_ham_ishres_dhires_b2,
	lts_aga_kehb_ishres_dhires_b2,
	lts_aga_n_ilores_dshres_b2,
	lts_aga_dpf_ilores_dshres_b2,
	lts_aga_ehb_ilores_dshres_b2,
	lts_aga_ham_ilores_dshres_b2,
	lts_aga_kehb_ilores_dshres_b2,
	lts_aga_n_ihires_dshres_b2,
	lts_aga_dpf_ihires_dshres_b2,
	lts_aga_ehb_ihires_dshres_b2,
	lts_aga_ham_ihires_dshres_b2,
	lts_aga_kehb_ihires_dshres_b2,
	lts_aga_n_ishres_dshres_b2,
	lts_aga_dpf_ishres_dshres_b2,
	lts_aga_ehb_ishres_dshres_b2,
	lts_aga_ham_ishres_dshres_b2,
	lts_aga_kehb_ishres_dshres_b2,
	NULL
};
static LINETOSRC_FUNCF linetoscr_aga_fast_funcs_filtered[] = {
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	lts_aga_n_ihires_dlores_b1_filtered,
	lts_aga_dpf_ihires_dlores_b1_filtered,
	lts_aga_ehb_ihires_dlores_b1_filtered,
	lts_aga_ham_ihires_dlores_b1_filtered,
	lts_aga_kehb_ihires_dlores_b1_filtered,
	lts_aga_n_ishres_dlores_b1_filtered,
	lts_aga_dpf_ishres_dlores_b1_filtered,
	lts_aga_ehb_ishres_dlores_b1_filtered,
	lts_aga_ham_ishres_dlores_b1_filtered,
	lts_aga_kehb_ishres_dlores_b1_filtered,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	lts_aga_n_ishres_dhires_b1_filtered,
	lts_aga_dpf_ishres_dhires_b1_filtered,
	lts_aga_ehb_ishres_dhires_b1_filtered,
	lts_aga_ham_ishres_dhires_b1_filtered,
	lts_aga_kehb_ishres_dhires_b1_filtered,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	lts_aga_n_ihires_dlores_b2_filtered,
	lts_aga_dpf_ihires_dlores_b2_filtered,
	lts_aga_ehb_ihires_dlores_b2_filtered,
	lts_aga_ham_ihires_dlores_b2_filtered,
	lts_aga_kehb_ihires_dlores_b2_filtered,
	lts_aga_n_ishres_dlores_b2_filtered,
	lts_aga_dpf_ishres_dlores_b2_filtered,
	lts_aga_ehb_ishres_dlores_b2_filtered,
	lts_aga_ham_ishres_dlores_b2_filtered,
	lts_aga_kehb_ishres_dlores_b2_filtered,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	lts_aga_n_ishres_dhires_b2_filtered,
	lts_aga_dpf_ishres_dhires_b2_filtered,
	lts_aga_ehb_ishres_dhires_b2_filtered,
	lts_aga_ham_ishres_dhires_b2_filtered,
	lts_aga_kehb_ishres_dhires_b2_filtered,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
};
